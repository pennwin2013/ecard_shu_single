/* --------------------------------------------
 * 创建日期: 2010-06-17
 * 程序作者: 闻剑
 * 版本信息: 3.0.0.0
 * 程序功能: 账务交易处理函数模块
 * --------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "errdef.h"
#include "pubdb.h"
#include "pubdef.h"
#include "pubfunc.h"
#include "dbfunc.h"
#include "dbfunc_foo.h"
#include "acctrans.h"
#include "interfacefunc.h"
#include "transfunc.h"
#include "logger_imp.h"

EXEC SQL INCLUDE SQLCA;

int StopBalance()
{
    char buffer[50];
    int ret = 0;
    memset(buffer, 0, sizeof(buffer));
    T_t_syspara tSysPara;
    memset(&tSysPara, 0, sizeof(tSysPara));

    ret = DB_t_syspara_read_lock_by_c0_and_paraid(GLOBE_FLAG_BALANCE, &tSysPara);
    if(ret)
    {
        LOG(ERROR, "Read syspara err [" << ret << "]");
        return E_SEARCH_FLAG;
    }
    if(strncmp(tSysPara.paraval, "1", 1) != 0)
    {
        strcpy(tSysPara.paraval, "1");

        ret = DB_t_syspara_update_lock_by_c0(&tSysPara);
        if(ret)
        {
            LOG(ERROR, "Write syspara err [" << ret << "]");
            return E_CHANGE_FLAG;
        }
    }
    else
    {
        LOG(DEBUG, "The value of balance parameter is '" << buffer << "',maybe there have another thread balancing now!");
        DB_t_syspara_free_lock_by_c0();
        return  E_BALANCE_NOW;
    }
    LOG(DEBUG, "Stop in balance succeed!");
    return 0;
}
int Startup()
{
    int ret = 0;
    ret = SetSysParaVal(GLOBE_FLAG_BALANCE, "0");
    if(ret)
    {
        LOG(ERROR, "Change system balance flag failed!");
        return ret;
    }
    return 0;
}

/*
int Cpack2Posdtl(ST_PACK *rPack,T_t_posdtl& posdtl)
{
    memcpy(posdtl.transdate,"20",2);
    memcpy(posdtl.transdate+2,rPack->spost_code,6);         //发生日期(格式化输入的日期)
    memcpy(posdtl.transtime,rPack->spost_code2,6);          //发生时间(格式化输入的时间)
    posdtl.cardno= rPack->lvol5;                            //交易卡号
    posdtl.cardcnt= rPack->lvol7;                           //当前卡中帐户消费次数(累计使用次数)
    posdtl.shopid=rPack->lvol3;
    posdtl.cardbefbal =  rPack->lvol9/100.0;                //入卡值
    posdtl.cardaftbal = rPack->lvol10/100.0;                //出卡值
    posdtl.amount = rPack->lvol8/100.0;                     //交易金额
    posdtl.managefee = rPack->lvol1/100.0;
    posdtl.subsidyno =rPack->lsafe_level;
    posdtl.datatype =rPack->lserial1;                       //流水类型
    posdtl.devseqno= rPack->lvol4;                          //上传端流水号
    posdtl.transmark = (unsigned char)rPack->lvol12;        //记录类型
    posdtl.sysid  = rPack->lcert_code;                      //上传工作站标识(前置机注册号)
    des2src(posdtl.devphyid,rPack->sphone3);                //物理设备ID
    return 0;
}
*/
int CheckCardCntExist(int cardno, int cardcnt, char *transdate)
{
    T_t_cardbitmap tCardBitmap;
    memset(&tCardBitmap, 0, sizeof(tCardBitmap));
    int ret = DB_t_cardbitmap_read_lock_by_cur_and_cardno(cardno, &tCardBitmap);
    if(ret)
    {
        if(DB_NOTFOUND == ret)
        {
            return 0;
        }
        else
            return E_DB_CARDBITMAP_R;
    }
    DB_t_cardbitmap_free_lock_cur();
    if(cardcnt <= tCardBitmap.baseno)
    {
        LOG(ERROR, "卡交易次数太小,卡号[" << cardno << "]卡交易次数[" << cardcnt << "]Bitmap baseno[" << tCardBitmap.baseno << "]");
        return ERRINFO(E_CARDCNT_TOO_SMALL, cardcnt);
    }
    unsigned int idxno = (cardcnt - tCardBitmap.baseno - 1) / 100;
    if(idxno >= 10)
        return 0;
    int offset = cardcnt - tCardBitmap.baseno - 1 - idxno * 100;
    char *p = (char*)(tCardBitmap.bitmap0);
    char bitmapflag = p[idxno * sizeof(tCardBitmap.bitmap0) + offset];

    switch(bitmapflag)
    {
        case CARDBITMAPTYPE_INIT:
            return 0;
        case CARDBITMAPTYPE_POS_OFFLINE:
            LOG(ERROR, "bitmapflag[" << bitmapflag << "]cardno[" << cardno << "]cardcnt[" << cardcnt << "]transdate[" << transdate << "] cardcnt exist");
            return ERRIF_CARDCNT_REPEAT;
        case CARDBITMAPTYPE_POS_ONLINE://以后可以考虑只考虑过期日期
        case CARDBITMAPTYPE_SYS_ONLINE://以后可以考虑只考虑过期日期
            LOG(ERROR, "bitmapflag[" << bitmapflag << "]cardno[" << cardno << "]cardcnt[" << cardcnt << "]transdate[" << transdate << "] cardcnt exist");
            return 0;
        case CARDBITMAPTYPE_REV:
        {
            CAccTrans *pAccTrans = CAccTrans::getInstance();
            char szExpireDate[9] = {0};
            calcEndDate(pAccTrans->trans.accdate, -POSDATA_EXPIRE_MAXDAY, szExpireDate);
            if(strncmp(transdate, szExpireDate, 8) < 0)
            {
                LOG(ERROR, "bitmapflag[" << bitmapflag << "]cardno[" << cardno << "]cardcnt[" << cardcnt << "]transdate[" << transdate << "] cardcnt except");
                return ERRIF_CARDCNT_EXCEPT;
            }
        }
        break;
        default:
            LOG(ERROR, "bitmapflag[" << bitmapflag << "]cardno[" << cardno << "]cardcnt[" << cardcnt << "]transdate[" << transdate << "] cardcnt except");
            return ERRIF_CARDCNT_EXCEPT;
    }
    return 0;
}

int UpdateCardBitmap(int cardno, int cardcnt, char type)
{
    EXEC SQL BEGIN DECLARE SECTION;
        int hi_cardno = 0;
        typedef struct
        {
            int       baseno;
            char  bitmap[10][101];
        } CARDCNTBITMAP;
        CARDCNTBITMAP  CardcntBitMap;
        short ho_bitmapidr;
    EXEC SQL END DECLARE SECTION;

    int ret = 0;
    hi_cardno = cardno;
    if(cardcnt < 1)
        return ERRIF_CARDCNT_EXCEPT;
    if(cardno < 1)
        return ERRIF_CARD_NOTEXIST;
    SQLCODE = 0;
    EXEC SQL DECLARE cardbitmap_cur CURSOR FOR SELECT
     baseno,
     bitmap0,
     bitmap1,
     bitmap2,
     bitmap3,
     bitmap4,
     bitmap5,
     bitmap6,
     bitmap7,
     bitmap8,
     bitmap9
    FROM t_cardbitmap
    WHERE cardno = :hi_cardno FOR UPDATE;
    if(SQLCODE)
    {
        db_chk_err(__FILE__, __LINE__, &sqlca);
        EXEC SQL CLOSE cardbitmap_cur;
        return E_DB_CURSOR_DECLARE;
    }
    EXEC SQL OPEN cardbitmap_cur;
    if(SQLCODE)
    {
        db_chk_err(__FILE__, __LINE__, &sqlca);
        EXEC SQL CLOSE cardbitmap_cur;
        return E_DB_CURSOR_OPEN;
    }
    memset(&CardcntBitMap, 0, sizeof(CardcntBitMap));
    EXEC SQL FETCH cardbitmap_cur INTO
    :CardcntBitMap.baseno:ho_bitmapidr,
    :CardcntBitMap.bitmap[0]:ho_bitmapidr,
    :CardcntBitMap.bitmap[1]:ho_bitmapidr,
    :CardcntBitMap.bitmap[2]:ho_bitmapidr,
    :CardcntBitMap.bitmap[3]:ho_bitmapidr,
    :CardcntBitMap.bitmap[4]:ho_bitmapidr,
    :CardcntBitMap.bitmap[5]:ho_bitmapidr,
    :CardcntBitMap.bitmap[6]:ho_bitmapidr,
    :CardcntBitMap.bitmap[7]:ho_bitmapidr,
    :CardcntBitMap.bitmap[8]:ho_bitmapidr,
    :CardcntBitMap.bitmap[9]:ho_bitmapidr;
    if(SQLCODE)
    {
        ret = SQLCODE;
        db_chk_err(__FILE__, __LINE__, &sqlca);
        EXEC SQL CLOSE cardbitmap_cur;
        if(DB_NOTFOUND == ret)
        {
            //对于系统移植时，卡片位图不存在的情况下，自动建立
            T_t_cardbitmap tCardBitmap;

            memset(&tCardBitmap, 0, sizeof(tCardBitmap));

            tCardBitmap.cardno = cardno;

            int num = (cardcnt - 1) / 1000;
            if(num < 1)
            {
                if(cardcnt > 900)
                    tCardBitmap.baseno = 500;
                else
                    tCardBitmap.baseno = 0;
            }
            else
            {
                int offsetcnt = cardcnt - num * 1000;
                if(offsetcnt < 100)
                    tCardBitmap.baseno = num * 1000 - 500;
                else if(offsetcnt > 600)
                    tCardBitmap.baseno = num * 1000 + 500;
                else
                    tCardBitmap.baseno = num * 1000;
            }
            int idxno = (cardcnt - 1 - tCardBitmap.baseno) / 100;
            int offset =  cardcnt - 1 - tCardBitmap.baseno - idxno * 100;
            char *p = (char*)(tCardBitmap.bitmap0);
            memset(p, '0', 10 * sizeof(tCardBitmap.bitmap0));
            //保留前50个次数
            if(offset > 50 || idxno > 0)
                memset(p, CARDBITMAPTYPE_POS_OFFLINE, idxno * sizeof(tCardBitmap.bitmap0) + offset - 50);
            p[idxno * sizeof(tCardBitmap.bitmap0) + offset] = type;
            tCardBitmap.bitmap0[100] = 0;
            tCardBitmap.bitmap1[100] = 0;
            tCardBitmap.bitmap2[100] = 0;
            tCardBitmap.bitmap3[100] = 0;
            tCardBitmap.bitmap4[100] = 0;
            tCardBitmap.bitmap5[100] = 0;
            tCardBitmap.bitmap6[100] = 0;
            tCardBitmap.bitmap7[100] = 0;
            tCardBitmap.bitmap8[100] = 0;
            tCardBitmap.bitmap9[100] = 0;
            ret = DB_t_cardbitmap_add(&tCardBitmap);
            if(ret)
            {
                if(DB_REPEAT == ret)
                    return E_DB_CARDBITMAP_E;
                else
                    return E_DB_CARDBITMAP_I;
            }
            return 0;
        }
        else
            return E_DB_CARDBITMAP_R;
    }
    if(cardcnt <= CardcntBitMap.baseno)
    {
        EXEC SQL CLOSE cardbitmap_cur;
        LOG(ERROR, "卡交易次数太小,卡号[" << cardno << "]卡交易次数[" << cardcnt << "]Bitmap baseno[" << CardcntBitMap.baseno << "]");
        return E_CARDCNT_TOO_SMALL;
    }
    //检查是否存在突变的卡交易次数
    unsigned int idxno = (cardcnt - CardcntBitMap.baseno - 1) / 100;
    int offset = cardcnt - CardcntBitMap.baseno - 1 - idxno * 100;
    if(idxno >= 10)
    {
        //查找前100笔有没有消费记录
        char *p = strrchr(CardcntBitMap.bitmap[9], CARDBITMAPTYPE_POS_ONLINE);
        if(NULL == p)
        {
            p = strrchr(CardcntBitMap.bitmap[9], CARDBITMAPTYPE_POS_OFFLINE);
            if(NULL == p)
            {
                EXEC SQL CLOSE cardbitmap_cur;
                LOG(ERROR, "卡交易次数太大,卡号[" << cardno << "]卡交易次数[" << cardcnt << "]Bitmap baseno[" << CardcntBitMap.baseno << "]");
                return ERRINFO(E_CARDCNT_TOO_BIG, cardcnt);

            }
        }
        //当前卡号超过最大号，则需要重置
        CardcntBitMap.baseno = CardcntBitMap.baseno + 500;
        memcpy(CardcntBitMap.bitmap[0], CardcntBitMap.bitmap[5], 100);
        memcpy(CardcntBitMap.bitmap[1], CardcntBitMap.bitmap[6], 100);
        memcpy(CardcntBitMap.bitmap[2], CardcntBitMap.bitmap[7], 100);
        memcpy(CardcntBitMap.bitmap[3], CardcntBitMap.bitmap[8], 100);
        memcpy(CardcntBitMap.bitmap[4], CardcntBitMap.bitmap[9], 100);
        memset(CardcntBitMap.bitmap[5], '0', 100);
        memset(CardcntBitMap.bitmap[6], '0', 100);
        memset(CardcntBitMap.bitmap[7], '0', 100);
        memset(CardcntBitMap.bitmap[8], '0', 100);
        memset(CardcntBitMap.bitmap[9], '0', 100);

        idxno = (cardcnt - CardcntBitMap.baseno - 1) / 100;
        offset = cardcnt - CardcntBitMap.baseno - 1 - idxno * 100;
        if(idxno != 5)
        {
            LOG(ERROR, "卡交易次数太大,卡号[" << cardno << "]卡交易次数[" << cardcnt << "]");
            EXEC SQL CLOSE cardbitmap_cur;
            return ERRINFO(E_CARDCNT_TOO_BIG, cardcnt);
        }
        CardcntBitMap.bitmap[5][offset] = type;
        EXEC SQL UPDATE t_cardbitmap SET
        baseno=:CardcntBitMap.baseno,
        bitmap0=:CardcntBitMap.bitmap[0],
        bitmap1=:CardcntBitMap.bitmap[1],
        bitmap2=:CardcntBitMap.bitmap[2],
        bitmap3=:CardcntBitMap.bitmap[3],
        bitmap4=:CardcntBitMap.bitmap[4],
        bitmap5=:CardcntBitMap.bitmap[5],
        bitmap6=:CardcntBitMap.bitmap[6],
        bitmap7=:CardcntBitMap.bitmap[7],
        bitmap8=:CardcntBitMap.bitmap[8],
        bitmap9=:CardcntBitMap.bitmap[9]
        WHERE current of cardbitmap_cur;
        if(SQLCODE)
        {
            db_chk_err(__FILE__, __LINE__, &sqlca);
            EXEC SQL CLOSE cardbitmap_cur;
            return E_DB_CARDBITMAP_U;
        }
    }
    else
    {
        //以下判断供联机消费使用，联机消费时如果位图不是脱机标志，则允许消费,脱机流水采用CheckCardCntExist判断
        if(CARDBITMAPTYPE_POS_OFFLINE == CardcntBitMap.bitmap[idxno][offset])
        {
            if(CARDBITMAPTYPE_POS_OFFLINE == type)
            {
                LOG(INFO, "pos offline trans:update cardbitmap flag orgi [" << CardcntBitMap.bitmap[idxno][offset] << "] new [" << type                     << "]");
                EXEC SQL CLOSE cardbitmap_cur;
                return ERRIF_CARDCNT_REPEAT;
            }
            if(CARDBITMAPTYPE_SYS_ONLINE == type)
            {
                LOG(INFO, "sys online trans:update cardbitmap flag orgi [" << CardcntBitMap.bitmap[idxno][offset] << "] new [" << type                      << "]");
                EXEC SQL CLOSE cardbitmap_cur;
                return 0;
            }
            if(CARDBITMAPTYPE_POS_ONLINE == type)
            {
                LOG(INFO, "pos online trans:update cardbitmap flag orgi [" << CardcntBitMap.bitmap[idxno][offset] << "] new [" << type                      << "]");
                EXEC SQL CLOSE cardbitmap_cur;
                return ERRIF_CARDCNT_REPEAT;
            }
            /*
            if(CARDBITMAPTYPE_REV==type)
            {
              LOG(INFO,"pos reverse trans:update cardbitmap flag orgi ["<<CardcntBitMap.bitmap[idxno][offset]<<"] new ["<<type                        <<"]");
            }
            if(CARDBITMAPTYPE_INIT==type)
            {
              //重置,脱机流水
              LOG(INFO,"rev trans:update cardbitmap flag orgi ["<<CardcntBitMap.bitmap[idxno][offset]<<"] new ["<<type                        <<"]");
            }
            */
        }
        CardcntBitMap.bitmap[idxno][offset] = type;
        switch(idxno)
        {
            case 0:
                EXEC SQL UPDATE t_cardbitmap SET bitmap0=:CardcntBitMap.bitmap[idxno] WHERE current of cardbitmap_cur;
                break;
            case 1:
                EXEC SQL UPDATE t_cardbitmap SET bitmap1=:CardcntBitMap.bitmap[idxno] WHERE current of cardbitmap_cur;
                break;
            case 2:
                EXEC SQL UPDATE t_cardbitmap SET bitmap2=:CardcntBitMap.bitmap[idxno] WHERE current of cardbitmap_cur;
                break;
            case 3:
                EXEC SQL UPDATE t_cardbitmap SET bitmap3=:CardcntBitMap.bitmap[idxno] WHERE current of cardbitmap_cur;
                break;
            case 4:
                EXEC SQL UPDATE t_cardbitmap SET bitmap4=:CardcntBitMap.bitmap[idxno] WHERE current of cardbitmap_cur;
                break;
            case 5:
                EXEC SQL UPDATE t_cardbitmap SET bitmap5=:CardcntBitMap.bitmap[idxno] WHERE current of cardbitmap_cur;
                break;
            case 6:
                EXEC SQL UPDATE t_cardbitmap SET bitmap6=:CardcntBitMap.bitmap[idxno] WHERE current of cardbitmap_cur;
                break;
            case 7:
                EXEC SQL UPDATE t_cardbitmap SET bitmap7=:CardcntBitMap.bitmap[idxno] WHERE current of cardbitmap_cur;
                break;
            case 8:
                EXEC SQL UPDATE t_cardbitmap SET bitmap8=:CardcntBitMap.bitmap[idxno] WHERE current of cardbitmap_cur;
                break;
            case 9:
                EXEC SQL UPDATE t_cardbitmap SET bitmap9=:CardcntBitMap.bitmap[idxno] WHERE current of cardbitmap_cur;
                break;
            default:
                break;
        }
        if(SQLCODE)
        {
            db_chk_err(__FILE__, __LINE__, &sqlca);
            EXEC SQL CLOSE cardbitmap_cur;
            return E_DB_CARDBITMAP_U;
        }
    }
    EXEC SQL CLOSE cardbitmap_cur;
    return 0;
}
//更新车载流水表记录状态
int UpdBusdtlStatusByRowid(char *rowid, int errcode, char *status)
{
    EXEC SQL BEGIN DECLARE SECTION;
        int hi_errcode = 0;
        int hi_termid = 0;      //终端ID
        int hi_termseqno = 0;   //终端流水号
        char     hi_rowid[31] = {0};    //记账日期
        char     hi_accdate[9] = {0};   //记账日期
        char     hi_acctime[7] = {0};   //记账时间
        char     hi_status[2] = {0};    //流水状态
        char     hi_errmsg[241] = {0}; //错误信息
        int hi_custid = 0;      //客户号
        int hi_feetype = 0;     //收费类别
        int hi_shopid = 0;      //商户ID
        char     hi_stuempno[21];   //学工号
        char     hi_deptcode[31];   //部门代码
        char     hi_custname[61];   //客户名称
    EXEC SQL END DECLARE SECTION;

    hi_errcode = errcode;
    des2src(hi_status, status);
    des2src(hi_rowid, rowid);
    CAccTrans *pAccTrans = CAccTrans::getInstance();
    des2src(hi_errmsg, pAccTrans->GetErrMsg(errcode).c_str());
    des2src(hi_accdate, pAccTrans->trans.accdate);
    des2src(hi_acctime, pAccTrans->trans.acctime);
    hi_custid = pAccTrans->trans.custid;
    hi_feetype = pAccTrans->trans.feetype;
    des2src(hi_stuempno, pAccTrans->trans.stuempno);
    des2src(hi_custname, pAccTrans->trans.custname);
    des2src(hi_deptcode, pAccTrans->trans.deptcode);
    hi_termid = pAccTrans->trans.termid;
    hi_termseqno = pAccTrans->trans.termseqno;
    hi_shopid = pAccTrans->trans.shopid;
    EXEC SQL
    update t_busdtl
    set status=:hi_status,errcode=:hi_errcode,
    accdate=:hi_accdate,acctime=:hi_acctime,termid=:hi_termid,termseqno=:hi_termseqno,
    errmsg=:hi_errmsg,custid=:hi_custid,stuempno=:hi_stuempno,deptcode=:hi_deptcode,
    feetype=:hi_feetype,custname=:hi_custname,shopid=:hi_shopid
    where rowid=:hi_rowid and status <>'3';
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        LOG(ERROR, "update t_posdtl rowid[" << hi_rowid << "]");
        if(DB_NOTFOUND == SQLCODE)
            return E_DB_BUSDTL_N;
        else
            return E_DB_BUSDTL_D;
    }
    return 0;
}
int UpdPosdtlStatusByRowid(char *rowid, int errcode, char *status)
{
    EXEC SQL BEGIN DECLARE SECTION;
        sqlint32 hi_errcode = 0;
        sqlint32 hi_termid = 0;     //终端ID
        sqlint32 hi_termseqno = 0;  //终端流水号
        char     hi_rowid[31] = {0};    //记账日期
        char     hi_accdate[9] = {0};   //记账日期
        char     hi_acctime[7] = {0};   //记账时间
        char     hi_status[2] = {0};    //流水状态
        char     hi_errmsg[241] = {0}; //错误信息
    EXEC SQL END DECLARE SECTION;

    hi_errcode = errcode;
    des2src(hi_status, status);
    des2src(hi_rowid, rowid);
    CAccTrans& ats = CAccTrans::GetInst();
    des2src(hi_errmsg, ats.GetErrMsg(errcode).c_str());
    des2src(hi_accdate, ats.trans.accdate);
    des2src(hi_acctime, ats.trans.acctime);
    hi_termid = ats.trans.termid;
    hi_termseqno = ats.trans.termseqno;
    EXEC SQL
    update t_posdtl
    set status=:hi_status,errcode=:hi_errcode,
    accdate=:hi_accdate,acctime=:hi_acctime,termid=:hi_termid,termseqno=:hi_termseqno,
    errmsg=:hi_errmsg
    where rowid=:hi_rowid and status <>'3';
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        LOG(ERROR, "update t_posdtl rowid=" << hi_rowid);
        if(DB_REPEAT == SQLCODE)
            return E_DB_POSDTL_E;
        else
            return E_DB_POSDTL_U;
    }
    return 0;
}
//更新流水表记录状态为无效
int UpdPosdtlInvalidStatusByRowid(char *rowid, int errcode)
{
    EXEC SQL BEGIN DECLARE SECTION;
        sqlint32 hi_errcode = 0;
        char     hi_rowid[31] = {0};    //记账日期
        char     hi_accdate[9] = {0};   //记账日期
        char     hi_acctime[7] = {0};   //记账时间
        char     hi_errmsg[241] = {0}; //错误信息
    EXEC SQL END DECLARE SECTION;

    hi_errcode = errcode;
    des2src(hi_rowid, rowid);
    CAccTrans *pAccTrans = CAccTrans::getInstance();
    strcpy(hi_errmsg, "重复流水");
    des2src(hi_accdate, pAccTrans->trans.accdate);
    des2src(hi_acctime, pAccTrans->trans.acctime);
    SQLCODE = 0;
    EXEC SQL
      update t_posdtl
      set status='5',errcode=:hi_errcode,
      errmsg=:hi_errmsg
    where rowid=:hi_rowid and status <>'3';
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        LOG(ERROR, "update t_posdtl rowid=" << hi_rowid);
        return E_DB_POSDTL_U;
    }
    return 0;
}

int UpdPosdtlStatus(char *transdate, char *devphyid, int devseqno, int errcode, char *status)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char     hi_transdate[9] = ""; //交易日期
        char     hi_devphyid[31] = ""; //设备物理ID
        int hi_devseqno = 0;
        int hi_errcode = 0;
        int hi_termid = 0;      //终端ID
        int hi_termseqno = 0;   //终端流水号
        char     hi_accdate[9] = "";    //记账日期
        char     hi_acctime[7] = "";
        char     hi_status[2] = ""; //流水状态
        char     hi_errmsg[241] = ""; //错误信息
    EXEC SQL END DECLARE SECTION;

    des2src(hi_transdate, transdate);
    des2src(hi_devphyid, devphyid);
    hi_devseqno = devseqno;
    hi_errcode = errcode;
    des2src(hi_status, status);
    CAccTrans *pAccTrans = CAccTrans::getInstance();
    des2src(hi_errmsg, pAccTrans->GetErrMsg(errcode).c_str());
    if(hi_status[0] == DTLSTATUS_SUCCESS)
    {
        des2src(hi_accdate, pAccTrans->trans.accdate);
        des2src(hi_acctime, pAccTrans->trans.acctime);
        hi_termid = pAccTrans->trans.termid;
        hi_termseqno = pAccTrans->trans.termseqno;
        EXEC SQL
        update t_posdtl
        set status=:hi_status,errcode=:hi_errcode,
        accdate=:hi_accdate,acctime=:hi_acctime,termid=:hi_termid,termseqno=:hi_termseqno,
        errmsg=:hi_errmsg
        where transdate =:hi_transdate and devphyid=:hi_devphyid and devseqno=:hi_devseqno and status<>'3';
        /*
        EXEC SQL
            delete from  t_posdtl
            where transdate =:hi_transdate and devphyid=:hi_devphyid and devseqno=:hi_devseqno;
        */
        if(SQLCODE)
        {
            CHECK_DB_ERR;
            LOG(ERROR, "delete transdate[" << hi_transdate << "]devphyid[" << hi_devphyid << "]devseqno[" << hi_devseqno << "]");
            if(DB_NOTFOUND == SQLCODE)
                return E_DB_POSDTL_N;
            else
                return E_DB_POSDTL_D;
        }
    }
    else
    {
        EXEC SQL
        update t_posdtl
        set status=:hi_status,errcode=:hi_errcode,
        errmsg=:hi_errmsg
        where transdate =:hi_transdate and devphyid=:hi_devphyid and devseqno=:hi_devseqno and status<>'3';
        if(SQLCODE)
        {
            CHECK_DB_ERR;
            LOG(ERROR, "update transdate[" << hi_transdate << "]devphyid[" << hi_devphyid << "]devseqno[" << hi_devseqno << "]");
            if(DB_NOTFOUND == SQLCODE)
                return E_DB_POSDTL_N;
            else
                return E_DB_POSDTL_U;
        }
    }
    return 0;
}
//考虑到性能，不使用动态语句
int UpdateTransdtlCurRevFlag(char *accdate, int termid, int termseqno)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char    hi_accdate[9] = {0};
        int hi_termid = 0;
        int     hi_termseqno = 0;
        short    ho_idr;
        char    ho_revflag[2];
    EXEC SQL END DECLARE SECTION;

    //LOG(INFO,"UpdateTransdtlCurRevFlag ReadLock :"<<getdbtimestamp(NULL)<<"");
    strncpy(hi_accdate, accdate, 8);
    hi_termid = termid;
    hi_termseqno = termseqno;

    SQLCODE = 0;
    EXEC SQL
     declare transdtl_cur cursor for
     select revflag
     from T_TRANSDTL
     where accdate=:hi_accdate
     and termid=:hi_termid
     and termseqno=:hi_termseqno for update;
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        return E_DB_CURSOR_DECLARE;
    }
    EXEC SQL open transdtl_cur;
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        return E_DB_CURSOR_DECLARE;
    }
    memset(ho_revflag, 0, sizeof(ho_revflag));
    EXEC SQL
     fetch transdtl_cur into
     :ho_revflag:ho_idr;
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        if(DB_NOTFOUND == SQLCODE)
        {
            EXEC SQL close transdtl_cur;
            return E_DB_TRANSDTL_N;
        }
        else
        {
            EXEC SQL close transdtl_cur;
            return E_DB_TRANSDTL_R;
        }
    }
    if('1' == ho_revflag[0])
    {
        EXEC SQL close transdtl_cur;
        return E_TRANS_REVERSED;
    }
    //LOG(INFO,"UpdateTransdtlRevFlag Update Start:"<<getdbtimestamp(NULL)<<"");
    EXEC SQL update T_TRANSDTL
     set revflag='1'
          WHERE current of transdtl_cur;
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        EXEC SQL close transdtl_cur;
        return E_DB_TRANSDTL_U;
    }
    EXEC SQL close transdtl_cur;
    //LOG(INFO,"UpdateTransdtlRevFlag End:"<<getdbtimestamp(NULL)<<"");
    return 0;
}

//更新冲正流水标志
int UpdateTransdtlHisRevFlag(const char *transdtlname, const char *accdate, int termid, int termseqno)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char        hi_sqlcmd[512] = "";
    EXEC SQL END DECLARE SECTION;

    SQLCODE = 0;
    sprintf(hi_sqlcmd, "update %s set revflag=1 where accdate='%s' and termid=%d and termseqno=%d and revflag=0 ", transdtlname, accdate, termid, termseqno);

    EXEC SQL EXECUTE IMMEDIATE :hi_sqlcmd;
    if(SQLCODE)
    {
        LOG(ERROR, "UpdateTransdtlRevFlag Sql[" << hi_sqlcmd << "]");
        //LOG(ERROR,"sqlcode["<<SQLCODE<<"]tablename["<<ho_tablename<<"]accdate["<<accdate<<"],termid["<<termid<<"],termseqno["<<termseqno<<"]");
        CHECK_DB_ERR;
        if(DB_NOTFOUND == SQLCODE)
        {
            SQLCODE = 0;
            //测试是否更新过
            sprintf(hi_sqlcmd, "update %s set revflag=1 where accdate='%s' and termid=%d and termseqno=%d and revflag=1 ", transdtlname, accdate, termid, termseqno);

            EXEC SQL EXECUTE IMMEDIATE :hi_sqlcmd;
            if(DB_SUCCESS == SQLCODE)
                return E_TRANS_REVERSED;
            else
            {
                if(DB_NOTFOUND == SQLCODE)
                    return E_DB_TRANSDTL_N;
                else
                    return E_DB_TRANSDTL_U;
            }
        }
        return E_DB_TRANSDTL_U;
    }
    return 0;
}//根据校区生成新客户号
int UpdTransdtlRevflag(char *accdate, int termid, int termseqno)
{
    int ret = 0;
    CAccTrans *pAccTrans = CAccTrans::getInstance();
    //查找上一笔消费流水
    if(strncmp(pAccTrans->trans.transdate, accdate, 8) == 0)
    {
        ret = UpdateTransdtlCurRevFlag(accdate, termid, termseqno);
        if(ret)
        {
            LOG(ERROR, "UpdateTransdtlCurRevFlag err[" << ret << "]");
            return ret;
        }
    }
    else
    {
        char transdtlname[61] = {0};
        ret = GetTransdtlTableName(accdate, transdtlname);
        if(ret)
        {
            LOG(ERROR, "GetTransdtlTableName ret[" << ret << "]");
            return ret;
        }
        //LOG(INFO,""<<getsystimestamp(NULL)<<":tablename["<<transdtlname<<"]UpdTransdtlRevflag UpdateTransdtlRevFlag");
        ret = UpdateTransdtlHisRevFlag(transdtlname, accdate, termid, termseqno);
        if(ret)
        {
            LOG(ERROR, "UpdateTransdtlRevFlag ret[" << ret << "]accdate[" << accdate << "]termid[" << termid << "]termseqno[" << termseqno << "]");
            return ret;
        }
    }
    //  LOG(INFO,"UpdTransdtlRevflag finish:"<<getdbtimestamp(NULL)<<"");
    return 0;
}
int UpdCardBalByAccno(char *accno, double cardbal, int transflag, int cardcnt, int revflag, int offlineflag)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char hi_accno[11] = {0};
        int  hi_cardcnt = 0;
        double hi_cardbal = 0;
        char ho_status[2] = {0};
        int  ho_paycnt = 0;
        int  ho_dpscnt = 0;
        double ho_cardbal = 0;
        short ho_idr;
    EXEC SQL END DECLARE SECTION;

    des2src(hi_accno, accno);
    hi_cardcnt = cardcnt;
    hi_cardbal = cardbal;
    SQLCODE = 0;
    SQLCODE = 0;
    EXEC SQL
     declare account_cur cursor for
     select status,cardbal,paycnt,dpscnt
     from T_ACCOUNT
     where accno=:hi_accno for update;
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        return E_DB_CURSOR_DECLARE;
    }
    EXEC SQL open account_cur;
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        return E_DB_CURSOR_DECLARE;
    }
    EXEC SQL
     fetch account_cur into
     :ho_status:ho_idr,
     :ho_cardbal:ho_idr,
     :ho_paycnt:ho_idr,
     :ho_dpscnt:ho_idr;
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        if(DB_NOTFOUND == SQLCODE)
        {
            EXEC SQL close account_cur;
            return E_DB_ACCOUNT_N;
        }
        else
        {
            EXEC SQL close account_cur;
            return E_DB_ACCOUNT_R;
        }
    }
    if(ho_status[0] != STATUS_NORMAL)
    {
        EXEC SQL close account_cur;
        return 0;
    }
    if(TF_PAY == transflag)
    {
        if(offlineflag)
        {
            if((hi_cardcnt <= ho_paycnt && ho_dpscnt <= ho_paycnt) ||
               (hi_cardcnt <= ho_dpscnt && ho_dpscnt >= ho_paycnt))
            {
                LOG(INFO, "offline account paycnt[" << ho_paycnt << "] input cardcnt[" << hi_cardcnt << "]");
                EXEC SQL close account_cur;
                return 0;
            }
        }
        if(revflag)
        {
            if(hi_cardcnt > 0)
                hi_cardcnt--;
        }
        EXEC SQL update T_ACCOUNT
        set cardbal = :hi_cardbal,
          paycnt =:hi_cardcnt
        WHERE current of account_cur;
    }
    else if(TF_DPS == transflag)
    {
        if(offlineflag)
        {
            if(ho_dpscnt > hi_cardcnt)
            {
                LOG(INFO, "offline account dpscnt[" << ho_dpscnt << "] input cardcnt[" << hi_cardcnt << "]");
                EXEC SQL close account_cur;
                return 0;
            }
        }
        if(revflag)
        {
            if(hi_cardcnt > 0)
                hi_cardcnt--;
        }
        EXEC SQL
        update t_account
        set cardbal = :hi_cardbal,
          dpscnt =:hi_cardcnt
        WHERE current of account_cur;
    }
    else
    {
        EXEC SQL
        update t_account
        set cardbal = :hi_cardbal
        WHERE current of account_cur;
    }
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        LOG(ERROR, "sqlcode[" << SQLCODE << "]accno[" << hi_accno << "]transflag[" << transflag << "]cardcnt[" << cardcnt << "]");
        return E_DB_ACCOUNT_U;
    }
    EXEC SQL close account_cur;
    return 0;
}
static int UpdTransdtlRevflagByPos(char *transdate, char *devphyid, int devseqno)
{
    int ret = 0;
    T_t_posdtl PosdtlBefore;

    memset(&PosdtlBefore, 0, sizeof(PosdtlBefore));
    //  LOG(INFO,"UpdTransdtlRevflagByPos find posdtl:"<<getdbtimestamp(NULL)<<"");
    //查找上一笔消费流水
    ret = DB_t_posdtl_read_by_transdate_and_devphyid_and_devseqno(transdate, devphyid, devseqno, &PosdtlBefore);
    if(ret)
    {
        LOG(ERROR, "DB_t_posdtl_read_by_transdate_and_devphyid_and_devseqno ret[" << ret << "]transdate[" << transdate << "]devphyid[" << devphyid << "]devseqno[" << devseqno << "]");

        if(DB_NOTFOUND == ret)
        {
            return E_DB_POSDTL_N;
        }
        else
            return E_DB_POSDTL_R;
    }
    if(PosdtlBefore.status[0] != DTLSTATUS_SUCCESS)
    {
        LOG(ERROR, "UpdTransdtlRevflagByPos posdtl status[" << PosdtlBefore.status << "] err,transdate[" << transdate << "]devphyid[" << devphyid << "]devseqno[" << devseqno << "]");
        return E_POSDTL_EXCEPTION;
    }
    ret = UpdTransdtlRevflag(PosdtlBefore.accdate, PosdtlBefore.termid, PosdtlBefore.termseqno);
    if(ret)
    {
        return ret;
    }
    return 0;
}
int UpdAllUnGetSubsidy(int cardno)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char    hi_getsubsidystatus[2] = {0};
        char    hi_putsubsidystatus[2] = {0};
        char    hi_transdate[9] = {0};
        char    hi_transtime[9] = {0};
        int hi_cardno = 0;
        short ho_idr;
    EXEC SQL END DECLARE SECTION;
    SQLCODE = 0;
    int ret = 0;
    hi_cardno = cardno;
    hi_getsubsidystatus[0] = SUBSIDY_STATUS_GET;
    hi_putsubsidystatus[0] = SUBSIDY_STATUS_PUT;
    CAccTrans *pAccTrans = CAccTrans::getInstance();
    TRANS& trans = pAccTrans->trans;
    des2src(hi_transdate, trans.transdate);
    des2src(hi_transtime, trans.transtime);
    EXEC SQL
    update t_subsidy
    set getdate=:hi_transdate,
     gettime=:hi_transtime,
     status=:hi_getsubsidystatus
    where cardno=:hi_cardno and subsidymode=0 and status=:hi_putsubsidystatus;
    if(SQLCODE)
    {
        db_chk_err(__FILE__, __LINE__, &sqlca);
        LOG(ERROR, "cardno[" << cardno << "]");
        if(DB_NOTFOUND == SQLCODE)
            return 0;
        else
            return E_DB_SUBSIDY_R;
    }
    return 0;
}
int GetNextTransCardbal(int cardno, int cardcnt, double& cardbefbal)
{
    EXEC SQL BEGIN DECLARE SECTION;
        int hi_cardno = 0;
        int hi_cardcnt = 0;
        double ho_cardbefbal = 0;
        short h_idr;
    EXEC SQL END DECLARE SECTION;

    hi_cardno = cardno;
    hi_cardcnt = cardcnt;

    EXEC SQL
     select cardbefbal into
     :ho_cardbefbal:h_idr
     from
     (select cardbefbal
     from v_recenttransdtl
     where cardno=:hi_cardno and cardcnt=:hi_cardcnt order by transdate,devphyid,devseqno)
     where rownum<=1;
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        LOG(ERROR, "cardno[" << hi_cardno << "]cardcnt[" << hi_cardcnt << "]");
        if(DB_NOTFOUND == SQLCODE)
            return E_NOTEXIST_NEXTTRANSDTL;
        else
            return E_DB_TRANSDTL_R;
    }
    cardbefbal = ho_cardbefbal;
    return 0;
}
int SaveLockCardTransdtl(T_t_posdtl& posdtl)
{
    int ret = 0;
    CAccTrans *pAccTrans = CAccTrans::getInstance();
    TRANS& trans = pAccTrans->trans;

    trans.transcode = TC_POSLOCKCARD;
    trans.cardno = posdtl.cardno;
    pAccTrans->trans.termid = posdtl.termid;
    ret = pAccTrans->GetTermSeqno();
    if(ret)
    {
        return ret;
    }
    ret = GetCardAccInfoByCardNo(posdtl.cardno, &trans.custid, NULL, trans.showcardno);
    if(ret)
    {
        LOG(ERROR, "GetCardAccInfoByCardNo ret[" << ret << "]cardno[" << posdtl.cardno << "]");
        return ret;
    }

    T_t_transdtl transdtl;

    memset(&transdtl, 0, sizeof(transdtl));
    ret = pAccTrans->GetNewRefno(trans.refno);
    if(ret)
        return ret;
    des2src(transdtl.refno, trans.refno);
    des2src(transdtl.transdate, posdtl.transdate);
    des2src(transdtl.transtime, posdtl.transtime);
    des2src(transdtl.accdate, trans.accdate);
    des2src(transdtl.acctime, trans.acctime);
    des2src(transdtl.coldate, posdtl.coldate);
    des2src(transdtl.coltime, posdtl.coltime);
    transdtl.termid = trans.termid;
    transdtl.termseqno = trans.termseqno;
    transdtl.transcode = trans.transcode;
    transdtl.cardno = posdtl.cardno;
    transdtl.cardcnt = posdtl.cardcnt;
    transdtl.cardbefbal = posdtl.cardbefbal;
    transdtl.cardaftbal = posdtl.cardaftbal;
    transdtl.amount = posdtl.amount;
    transdtl.managefee = posdtl.managefee;
    transdtl.sysid = posdtl.sysid;
    des2src(transdtl.devphyid, posdtl.devphyid);
    transdtl.devseqno = posdtl.devseqno;
    transdtl.offlineflag = posdtl.datatype;
    transdtl.transflag = TF_PAY;
    transdtl.status = TRANSTATUS_EXCEPT;
    transdtl.errcode = 0;
    des2src(transdtl.showcardno, trans.showcardno);
    transdtl.custid = trans.custid;
    GetCustBaseInfoByCustID(trans.custid, transdtl.custname, transdtl.stuempno, NULL);
    ret = DB_t_transdtl_add(&transdtl);
    if(ret)
    {
        if(DB_REPEAT == ret)
            return E_DB_TRANSDTL_E;
        else
            return E_DB_TRANSDTL_I;
    }
    return 0;
}
//保存中途拔卡消费失败流水
int SaveConsumeFailTransdtl(T_t_posdtl& posdtl)
{
    int ret = 0;
    CAccTrans *pAccTrans = CAccTrans::getInstance();
    TRANS& trans = pAccTrans->trans;

    trans.transcode = TC_CONSUMEFAIL;
    trans.cardno = posdtl.cardno;
    pAccTrans->trans.termid = posdtl.termid;
    ret = pAccTrans->GetTermSeqno();
    if(ret)
    {
        return ret;
    }
    ret = GetCardAccInfoByCardNo(posdtl.cardno, &trans.custid, NULL, trans.showcardno);
    if(ret)
    {
        LOG(ERROR, "GetCardAccInfoByCardNo ret[" << ret << "]cardno[" << posdtl.cardno << "]");
        return ret;
    }

    T_t_transdtl transdtl;

    memset(&transdtl, 0, sizeof(transdtl));

    memset(&transdtl, 0, sizeof(transdtl));
    if(strlen(trans.refno) < 1)
    {
        ret = pAccTrans->GetNewRefno(trans.refno);
        if(ret)
            return ret;
    }
    des2src(transdtl.refno, trans.refno);
    des2src(transdtl.transdate, posdtl.transdate);
    des2src(transdtl.transtime, posdtl.transtime);
    des2src(transdtl.accdate, trans.accdate);
    des2src(transdtl.acctime, trans.acctime);
    des2src(transdtl.coldate, posdtl.coldate);
    des2src(transdtl.coltime, posdtl.coltime);
    transdtl.termid = trans.termid;
    transdtl.termseqno = trans.termseqno;
    transdtl.transcode = trans.transcode;
    transdtl.cardno = posdtl.cardno;
    transdtl.cardcnt = posdtl.cardcnt;
    transdtl.cardbefbal = posdtl.cardbefbal;
    transdtl.cardaftbal = posdtl.cardaftbal;
    transdtl.amount = posdtl.amount;
    transdtl.managefee = posdtl.managefee;
    transdtl.sysid = posdtl.sysid;
    des2src(transdtl.devphyid, posdtl.devphyid);
    transdtl.devseqno = posdtl.devseqno;
    transdtl.offlineflag = posdtl.datatype;
    transdtl.transflag = TF_PAY;
    transdtl.status = TRANSTATUS_EXCEPT;
    transdtl.errcode = 0;
    des2src(transdtl.showcardno, trans.showcardno);
    transdtl.custid = trans.custid;
    GetCustBaseInfoByCustID(trans.custid, transdtl.custname, transdtl.stuempno, NULL);
    ret = DB_t_transdtl_add(&transdtl);
    if(ret)
    {
        if(DB_REPEAT == ret)
            return E_DB_TRANSDTL_E;
        else
            return E_DB_TRANSDTL_I;
    }
    return 0;
}


//POS联机消费取消
int PosTransCancelProcess(T_t_posdtl& posdtl)
{
    int ret = 0;
    CAccTrans *pAccTrans = CAccTrans::getInstance();
    TRANS& trans = pAccTrans->trans;
    trans.revflag = 1; //冲正标志
    trans.cardflag = 1;
    trans.offlineflag = 1;
    trans.termid = posdtl.termid;
    trans.cardno = posdtl.cardno;
    trans.paycnt = posdtl.cardcnt;
    trans.aftpaycnt = posdtl.cardcnt;
    trans.cardbefbal = D2I(posdtl.cardbefbal * 100);
    trans.cardaftbal = D2I(posdtl.cardaftbal * 100);
    trans.transcode = TC_POSDRAWCANCEL;
    memcpy(trans.transdate, posdtl.transdate, 8);
    memcpy(trans.transtime, posdtl.transtime, 6);
    ret = UpdTransdtlRevflagByPos(posdtl.transdate, posdtl.devphyid, posdtl.devseqno - 1);
    if(ret)
    {
        return ret;
    }
    ret = UpdateCardBitmap(posdtl.cardno, posdtl.cardcnt, CARDBITMAPTYPE_REV);
    if(ret)
    {
        return ret;
    }
    ret = GetCardAccInfoByCardNo(trans.cardno, &trans.custid, trans.cardaccno, trans.showcardno);
    if(ret)
    {
        LOG(ERROR, "GetCardAccInfoByCardNo ret[" << ret << "]cardno[" << trans.cardno << "]");
        return ret;
    }
    int shoptype = 0;
    char shopstatus[2] = {0};
    char boardfeeflag[2] = {0};
    ret = ShopAccReadbyShopid(posdtl.shopid, trans.shopaccno, &shoptype, shopstatus, boardfeeflag);
    if(ret)
    {
        LOG(ERROR, "shopid[" << posdtl.shopid << "]");
        return ret;
    }
    if(shopstatus[0] != STATUS_NORMAL)
        return ERRIF_SHOP_CLOSE;
    if(shoptype != SHOPTYPE_COSUMESHOP)
        return ERRIF_SHOP_TYPE;
    //正常记录
    trans.transtype = TRANSTYPE_POSPAYCANCEL;
    //作为负金额
    trans.transamt = D4U5(posdtl.amount - posdtl.managefee);
    if(amtcmp(trans.transamt, 0) > 0)
        trans.transamt = - trans.transamt;
    trans.inputamt = trans.transamt;
    trans.unusedamt = trans.inputamt;
    //获取终端流水号
    ret = pAccTrans->GetTermSeqno();
    if(ret)
    {
        LOG(ERROR, "GetTermSeqno ret[" << ret << "]");
        if(E_ACCDATE_NOSWITCH == ret)
            return ERRIF_SYS_DAYENDACC;
        else
            return ERRIF_DATABASE_UPD;
    }
    trans.transtype = TRANSTYPE_POSPAYCANCEL;
    ret = pAccTrans->DoTransByTransType();
    if(ret)
    {
        LOG(ERROR, "DoTransByTransType ret=" << ret << "");
        if(E_CARDACC_LOGOUT == ret)
            return ERRIF_CARD_CLOSE;
        else
            return ERRIF_SYSTEM;
    }
    if(amtcmp(pAccTrans->trans.unusedamt, 0) > 0)
        return ERRIF_CARDBAL_SHORTAGE;
    if(amtcmp(pAccTrans->trans.unusedamt, 0) < 0)
        return ERRIF_CARDBAL_EXCEPT;
    //正常流水
    if(pAccTrans->sysPara.iShopBoardFeeFlag)
    {
        trans.transtype = TRANSTYPE_SHOPBOARDFEE;
        trans.transamt = posdtl.managefee;
        trans.inputamt = trans.transamt;
        trans.unusedamt = trans.inputamt;
        ret = pAccTrans->DoTransByTransType();
        if(ret)
        {
            LOG(ERROR, "DoTransByTransType ret=" << ret << "");
            if(E_CARDACC_LOGOUT == ret)
                return ERRIF_CARD_CLOSE;
            else
                return ERRIF_SYSTEM;
        }
        if(amtcmp(pAccTrans->trans.unusedamt, 0) > 0)
            return ERRIF_CARDBAL_SHORTAGE;
        if(amtcmp(pAccTrans->trans.unusedamt, 0) < 0)
            return ERRIF_CARDBAL_EXCEPT;
    }
    else
    {
        trans.transtype = TRANSTYPE_BOARDFEE;
        trans.transamt = posdtl.managefee;
        trans.inputamt = trans.transamt;
        trans.unusedamt = trans.inputamt;
        ret = pAccTrans->DoTransByTransType();
        if(ret)
        {
            LOG(ERROR, "DoTransByTransType ret=" << ret << "");
            if(E_CARDACC_LOGOUT == ret)
                return ERRIF_CARD_CLOSE;
            else
                return ERRIF_SYSTEM;
        }
        if(amtcmp(pAccTrans->trans.unusedamt, 0) > 0)
            return ERRIF_CARDBAL_SHORTAGE;
        if(amtcmp(pAccTrans->trans.unusedamt, 0) < 0)
            return ERRIF_CARDBAL_EXCEPT;
    }
    double dCardAftbal = trans.cardaftbal / 100.0;
    ret = UpdCardBalByAccno(trans.cardaccno, dCardAftbal, TF_PAY, trans.paycnt, 1, 1);
    if(ret)
    {
        return ret;
    }
    T_t_transdtl transdtl;
    memset(&transdtl, 0, sizeof(transdtl));
    if(strlen(trans.refno) < 1)
    {
        ret = pAccTrans->GetNewRefno(trans.refno);
        if(ret)
            return ret;
    }
    des2src(transdtl.refno, trans.refno);
    transdtl.offlineflag = posdtl.datatype;
    des2src(transdtl.transdate, trans.transdate);
    des2src(transdtl.transtime, trans.transtime);
    strcpy(transdtl.accdate, trans.accdate);
    strcpy(transdtl.acctime, trans.acctime);
    transdtl.termid = trans.termid;
    transdtl.termseqno = trans.termseqno;
    transdtl.transcode = trans.transcode;
    //  transdtl.paytype=trans.fundtype;
    //  des2src(transdtl.voucherno,trans.voucherno);
    transdtl.cardno = trans.cardno;
    transdtl.transflag = TF_PAY;
    transdtl.cardcnt = trans.paycnt;
    transdtl.cardbefbal = D4U5(trans.cardbefbal / 100.0);
    transdtl.cardaftbal = D4U5(trans.cardaftbal / 100.0);
    transdtl.amount = trans.totaltransamt;
    transdtl.managefee = posdtl.managefee;;
    transdtl.custid = trans.custid;
    transdtl.sysid = posdtl.sysid;
    des2src(transdtl.coldate, posdtl.coldate);
    des2src(transdtl.coltime, posdtl.coltime);
    des2src(transdtl.devphyid, posdtl.devphyid);
    transdtl.devseqno = posdtl.devseqno;
    des2src(transdtl.opercode, trans.opercode);
    des2src(transdtl.showcardno, trans.showcardno);
    transdtl.status = TRANSTATUS_SUCC;
    GetCustBaseInfoByCustID(trans.custid, transdtl.custname, transdtl.stuempno, NULL);
    ret = DB_t_transdtl_add(&transdtl);
    if(ret)
    {
        if(DB_REPEAT == ret)
            return ERRIF_DATABASE_REPEAT;
        else
            return ERRIF_DATABASE_INS;
    }
    strcpy(posdtl.accdate, trans.accdate);
    strcpy(posdtl.acctime, trans.acctime);
    posdtl.termid = trans.termid;
    posdtl.termseqno = trans.termseqno;
    return 0;
}
//POS脱机消费
int PosOfflineTransProcess(T_t_posdtl& posdtl)
{
    int ret = 0;
    T_t_device tDevice;
    memset(&tDevice, 0, sizeof(tDevice));
    ret = DB_t_device_read_by_deviceid(posdtl.termid, &tDevice);
    if(ret)
    {
        if(DB_NOTFOUND == ret)
            return E_NOTEXIST_DEVICE;
        else
            return E_DB_DEVICE_R;
    }
    /*
    if((strcmp(tDevice.devtypecode,"0244")==0)||(strcmp(tDevice.devtypecode,"0245")==0))
    {
      posdtl.status[0]=DTLSTATUS_INVALID;
      return E_999_CRC;                   //上传流水CRC校验错
    }
    */
    CAccTrans *pAccTrans = CAccTrans::getInstance();
    TRANS& trans = pAccTrans->trans;
    if(0xFF == posdtl.transmark)
    {
        //对于水控设备,0xFF的中途拔卡流水标志为0xFF,且交易次数与上一笔流水一致
        //三九  0244 0245表示水控设备
        if((strcmp(tDevice.devtypecode, "0244") != 0) && (strcmp(tDevice.devtypecode, "0245") != 0))
        {
            posdtl.status[0] = DTLSTATUS_INVALID;
            return E_999_CRC;                   //上传流水CRC校验错
        }
        //判断该笔流水是否处理过
        T_t_posseqno    tPosSeqno;

        memset(&tPosSeqno, 0, sizeof(tPosSeqno));

        tPosSeqno.deviceid = posdtl.termid;
        tPosSeqno.devseqno = posdtl.devseqno;
        des2src(tPosSeqno.transdate, posdtl.transdate);
        ret = DB_t_posseqno_add(&tPosSeqno);
        if(ret)
        {
            LOG(ERROR, "ret[" << ret << "]deviceid[" << tPosSeqno.deviceid << "]devphyid[" << posdtl.devphyid << "]devseqno[" << tPosSeqno.devseqno << "]transdate[" << tPosSeqno.transdate << "]");
            if(DB_REPEAT == ret)
            {
                //说明记录已经存在，不需要再处理了
                posdtl.status[0] = DTLSTATUS_INVALID;
                return ret;
            }
            else
            {
                return ERRIF_DATABASE_INS;
            }
        }
    }
    else
    {
        // modify by tc
        #if 0
        if(posdtl.subsidyno != -9999)
        {
            //判断卡交易位图表该交易是否已经处理过
            ret = CheckCardCntExist(posdtl.cardno, posdtl.cardcnt, posdtl.transdate);
            if(ret)
            {
                if(ERRIF_CARDCNT_REPEAT == ret)
                {
                    posdtl.status[0] = DTLSTATUS_REPEAT;
                    return ret;
                    //如果没有
                }
                else
                {
                    posdtl.status[0] = DTLSTATUS_EXCEPT;
                    return ret;
                }
            }
            //更新交易位图
            ret = UpdateCardBitmap(posdtl.cardno, posdtl.cardcnt, CARDBITMAPTYPE_POS_OFFLINE);
            if(ret)
            {
                if(ERRIF_CARDCNT_REPEAT == ret)
                {
                    posdtl.status[0] = DTLSTATUS_REPEAT;
                    return ret;
                    //如果没有
                }
                else if(E_CARDCNT_TOO_SMALL == ret)
                {
                    posdtl.status[0] = DTLSTATUS_REPEAT;
                    return ret;
                }
                else
                {
                    posdtl.status[0] = DTLSTATUS_EXCEPT;
                    return ret;
                }
            }
        }
		#endif
    }
    T_t_card  tCard;
    memset(&tCard, 0, sizeof(tCard));
    ret = DB_t_card_read_by_cardno(posdtl.cardno, &tCard);
    if(ret)
    {
        if(DB_NOTFOUND == ret)
            return E_NOTEXIST_CARDNO;
        else
            return E_DB_CARD_R;
    }
    if((STATUS_DELETE != tCard.status[0]) && ('1' == tCard.lossflag[0]))
    {
        //不是坏卡登记的挂失
        if(tCard.badflag[0] != '1')
        {
            char trandatetime[15] = {0};
            memcpy(trandatetime, posdtl.transdate, 8);
            memcpy(trandatetime + 8, posdtl.transtime, 6);
            if(strncmp(trandatetime, tCard.lossefttime, 14) > 0)
            {
                LOG(ERROR, "cardno[" << posdtl.cardno << " lost ,effect time=" << tCard.lossefttime << ",pos transtime=" << trandatetime);
                return E_CARD_LOST;
            }
        }
    }
    T_t_account tAccount;
    memset(&tAccount, 0, sizeof(tAccount));
    ret = CardAccInfoReadbyAccno(tCard.accno, &tAccount);
    if(ret)
    {
        return ret;
    }
    des2src(trans.transdate, posdtl.transdate);
    des2src(trans.transtime, posdtl.transtime);
    trans.usecardflag = 1;
    trans.transcode = TC_POSDRAW;
    if(940031 == posdtl.transcode)
        trans.transcode = TC_BUSDRAW;
    trans.custid = tCard.custid;
    trans.feetype = tCard.feetype;
    trans.cardno = posdtl.cardno;
    trans.paycnt = posdtl.cardcnt;
    trans.aftpaycnt = posdtl.cardcnt;
    trans.transflag = TF_PAY;
    trans.cardbefbal = D2I(posdtl.cardbefbal * 100);
    trans.cardaftbal = D2I(posdtl.cardaftbal * 100);
    trans.usecardflag = 1;
    trans.cardflag = 1;
    trans.offlineflag = 1;
    trans.cardtype = tCard.cardphytype;
    trans.cardphytype = tCard.cardphytype;
    des2src(trans.cardaccno, tCard.accno);
    //如果是中途拔卡
    if(0x02 == posdtl.transmark || 0xFF == posdtl.transmark)
    {
        //查找下一笔流水是否已经入账
        if(STATUS_DELETE == tCard.status[0])
        {
            posdtl.status[0] = DTLSTATUS_INVALID;
            return ERRINFO(E_CARD_LOGOUT, posdtl.cardno);
        }
        if(posdtl.cardcnt >= tAccount.paycnt)
        {
            //后续流水还没有传上来
            LOG(ERROR, "posdtl cardcnt[" << posdtl.cardcnt << "] account paycnt");
            return E_NOTEXIST_NEXTTRANSDTL;
        }
        //查找该笔流水
        double cardbefbal = 0;
        ret = GetNextTransCardbal(posdtl.cardno, posdtl.cardcnt + 1, cardbefbal);
        if(ret)
        {
            return ret;
        }
        //如果当前流水出卡值不等于下一笔流水的入卡值，则说明该流水无效
        if(amtcmp(posdtl.cardaftbal, cardbefbal) != 0)
        {
            posdtl.status[0] = DTLSTATUS_INVALID;
            return ERRINFO(E_POSDTL_INVALID, posdtl.cardaftbal, cardbefbal);
        }
    }
    //根据pos的设备物理ID、交易日期、交易时间、
    //查询该设备对应的商户
    if(12336 == posdtl.shopid)
        posdtl.shopid = 0;
    if(!posdtl.shopid)
    {
        int deviceid = 0;
        ret = GetShopidByDevphyid(posdtl.devphyid, posdtl.transdate, posdtl.transtime, deviceid, posdtl.shopid);
        if(ret)
        {
            return ret;
        }
    }
    /*
    if(strncmp(posdtl.transdate,pAccTrans->sysPara.sPosdtlExpireDate,8)<=0)
    {

        posdtl.status[0]=DTLSTATUS_EXCEPT;
        return E_POSDTL_EXPIRED;
    }
    */
    int shopflag = 0;
    int cardflag = 0;
    /*
    else if('1'==card.lossflag[0])
    {
      //如果挂失生效时间启用
      if(pAccTrans->sysPara.iLossEffectTime>0)
      {
        //如果卡挂失,则判断是否达到生效时间，
        //如果超过生效时间，则从平帐帐户扣帐
        if(strncmp(posdtl.transdate,card.lossefttime,8)==0)
        {
            if(strncmp(posdtl.transtime,card.lossefttime+8,6)>=0)
                cardflag=1;
        }
        else if(strncmp(posdtl.transdate,card.lossefttime,8)>0)
            cardflag=1;
      }
    }
    */
    //检查卡库不平表是否存在已平账记录，如果存在，则对于已平账的不扣个人账户
    /*
    int maxcardcnt=0;
    ret=GetCardAccDiffMaxCardCnt(posdtl.cardno,maxcardcnt);
    if(ret)
      return ret;
    if(maxcardcnt>=posdtl.cardcnt)
      cardflag=1;
    */
    int shoptype = 0;
    char shopstatus[2] = {0};
    char boardfeeflag[2] = {0};
    ret = ShopAccReadbyShopid(posdtl.shopid, trans.shopaccno, &shoptype, shopstatus, boardfeeflag);
    if(ret)
    {
        LOG(ERROR, "shopid=" << posdtl.shopid);
        return ret;
    }
    if(shoptype != SHOPTYPE_COSUMESHOP)
        return ERRIF_SHOP_TYPE;
    if(shopstatus[0] != STATUS_NORMAL)
    {
        //shopflag = 1;
        posdtl.status[0] = DTLSTATUS_EXCEPT;
        return ERRIF_SHOP_CLOSE;
    }
    des2src(trans.draccno, trans.cardaccno);
    des2src(trans.craccno, trans.shopaccno);
    ret = pAccTrans->GetTermSeqno();
    if(ret)
    {
        return ret;
    }
    if(cardflag > 0 && shopflag > 0)
    {
        //卡户和商户都账号都不能入账
        if(pAccTrans->sysPara.iShopBoardFeeFlag)
        {
            trans.transtype = TRANSTYPE_LESSOUT2MOREIN;
            trans.transamt = posdtl.amount;
            trans.inputamt = trans.transamt;
            trans.unusedamt = trans.inputamt;
            ret = pAccTrans->DoTransByTransType();
            if(ret)
                return ret;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) > 0)
                return E_INPUT_AMT;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) < 0)
                return E_AMT_LACK;
        }
        else
        {
            trans.transtype = TRANSTYPE_LESSOUT2MOREIN;
            trans.transamt = D4U5(posdtl.amount - posdtl.managefee);
            trans.inputamt = trans.transamt;
            trans.unusedamt = trans.inputamt;
            ret = pAccTrans->DoTransByTransType();
            if(ret)
                return ret;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) > 0)
                return E_INPUT_AMT;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) < 0)
                return E_AMT_LACK;
            trans.transtype = TRANSTYPE_LESS_SCHOOLBOARDFEE;
            trans.transamt = posdtl.managefee;
            trans.inputamt = trans.transamt;
            trans.unusedamt = trans.inputamt;
            ret = pAccTrans->DoTransByTransType();
            if(ret)
                return ret;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) > 0)
                return E_INPUT_AMT;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) < 0)
                return E_AMT_LACK;
        }
    }
    else if(cardflag)
    {
        // 卡户账户挂失或注销
        if(pAccTrans->sysPara.iShopBoardFeeFlag)
        {
            trans.transtype = TRANSTYPE_LESS_POSPAYMENT;
            trans.transamt = posdtl.amount;
            trans.inputamt = trans.transamt;
            trans.unusedamt = trans.inputamt;
            ret = pAccTrans->DoTransByTransType();
            if(ret)
                return ret;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) > 0)
                return E_INPUT_AMT;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) < 0)
                return E_AMT_LACK;
            trans.transtype = TRANSTYPE_LESS_SHOPBOARDFEE;
            trans.transamt = posdtl.managefee;
            trans.inputamt = trans.transamt;
            trans.unusedamt = trans.inputamt;
            ret = pAccTrans->DoTransByTransType();
            if(ret)
                return ret;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) > 0)
                return E_INPUT_AMT;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) < 0)
                return E_AMT_LACK;
        }
        else
        {
            trans.transtype = TRANSTYPE_LESS_POSPAYMENT;
            trans.transamt = D4U5(posdtl.amount - posdtl.managefee);
            trans.inputamt = trans.transamt;
            trans.unusedamt = trans.inputamt;
            ret = pAccTrans->DoTransByTransType();
            if(ret)
                return ret;
            if(pAccTrans->trans.unusedamt > 0)
                return E_INPUT_AMT;
            if(pAccTrans->trans.unusedamt < 0)
                return E_AMT_LACK;
            trans.transtype = TRANSTYPE_LESS_SCHOOLBOARDFEE;
            trans.transamt = posdtl.managefee;
            trans.inputamt = trans.transamt;
            trans.unusedamt = trans.inputamt;
            ret = pAccTrans->DoTransByTransType();
            if(ret)
                return ret;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) > 0)
                return E_INPUT_AMT;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) < 0)
                return E_AMT_LACK;
        }
    }
    else if(shopflag)
    {
        // 商户账户挂失或注销
        if(pAccTrans->sysPara.iShopBoardFeeFlag)
        {
            trans.transtype = TRANSTYPE_MORE_POSPAYMENT;
            trans.transamt = posdtl.amount;
            trans.inputamt = trans.transamt;
            trans.unusedamt = trans.inputamt;
            ret = pAccTrans->DoTransByTransType();
            if(ret)
                return ret;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) > 0)
                return E_INPUT_AMT;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) < 0)
                return E_AMT_LACK;
        }
        else
        {
            trans.transtype = TRANSTYPE_MORE_POSPAYMENT;
            trans.transamt = D4U5(posdtl.amount - posdtl.managefee);
            trans.inputamt = trans.transamt;
            trans.unusedamt = trans.inputamt;
            ret = pAccTrans->DoTransByTransType();
            if(ret)
                return ret;
            if(pAccTrans->trans.unusedamt > 0)
                return E_INPUT_AMT;
            if(pAccTrans->trans.unusedamt < 0)
                return E_AMT_LACK;
            trans.transtype = TRANSTYPE_BOARDFEE;
            trans.transamt = posdtl.managefee;
            trans.inputamt = trans.transamt;
            trans.unusedamt = trans.inputamt;
            ret = pAccTrans->DoTransByTransType();
            if(ret)
                return ret;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) > 0)
                return E_INPUT_AMT;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) < 0)
                return E_AMT_LACK;
        }
    }
    else
    {
        //正常记录
        trans.transtype = TRANSTYPE_POSPAYMENT;
        trans.transamt = D4U5(posdtl.amount - posdtl.managefee);
        trans.inputamt = trans.transamt;
        trans.unusedamt = trans.inputamt;
        ret = pAccTrans->DoTransByTransType();
        if(ret)
            return ret;
        if(pAccTrans->trans.unusedamt > 0)
            return E_INPUT_AMT;
        if(pAccTrans->trans.unusedamt < 0)
            return E_AMT_LACK;
        //正常流水
        if(1 == pAccTrans->sysPara.iShopBoardFeeFlag)
        {
            trans.transtype = TRANSTYPE_SHOPBOARDFEE;
            trans.transamt = posdtl.managefee;
            trans.inputamt = trans.transamt;
            trans.unusedamt = trans.inputamt;
            ret = pAccTrans->DoTransByTransType();
            if(ret)
                return ret;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) > 0)
                return E_INPUT_AMT;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) < 0)
                return E_AMT_LACK;
        }
        else if((2 == pAccTrans->sysPara.iShopBoardFeeFlag) && ('1' == boardfeeflag[0]))
        {
            trans.transtype = TRANSTYPE_SHOPBOARDFEE2;
            int iAmount = D2I(posdtl.amount * 100);
            int iBoardfee = 0;
            ret = CalcPrestoreFee(trans.feetype, iAmount, &iBoardfee);
            if(ret)
                return ret;
            posdtl.managefee = D4U5(iBoardfee / 100.0);
            trans.transamt = posdtl.managefee;
            trans.inputamt = trans.transamt;
            trans.unusedamt = trans.inputamt;
            ret = pAccTrans->DoTransByTransType();
            if(ret)
                return ret;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) > 0)
                return E_INPUT_AMT;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) < 0)
                return E_AMT_LACK;
        }
        else
        {
            trans.transtype = TRANSTYPE_BOARDFEE;
            trans.transamt = posdtl.managefee;
            trans.inputamt = trans.transamt;
            trans.unusedamt = trans.inputamt;
            ret = pAccTrans->DoTransByTransType();
            if(ret)
                return ret;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) > 0)
                return E_INPUT_AMT;
            if(amtcmp(pAccTrans->trans.unusedamt, 0) < 0)
                return E_AMT_LACK;
        }
    }
    //添加卡交易流水表
    T_t_transdtl transdtl;
    memset(&transdtl, 0, sizeof(transdtl));
    ret = pAccTrans->GetNewRefno(trans.refno);
    if(ret)
        return ret;
    des2src(transdtl.refno, trans.refno);
    des2src(transdtl.transdate, posdtl.transdate);
    des2src(transdtl.transtime, posdtl.transtime);
    des2src(transdtl.accdate, trans.accdate);
    des2src(transdtl.acctime, trans.acctime);
    des2src(transdtl.coldate, posdtl.coldate);
    des2src(transdtl.coltime, posdtl.coltime);
    transdtl.termid = trans.termid;
    transdtl.termseqno = trans.termseqno;
    transdtl.transcode = trans.transcode;
    transdtl.cardno = posdtl.cardno;
    transdtl.cardcnt = posdtl.cardcnt;
    transdtl.transflag = TF_PAY;
    transdtl.cardbefbal = posdtl.cardbefbal;
    transdtl.cardaftbal = posdtl.cardaftbal;
    transdtl.amount = posdtl.amount;
    transdtl.managefee = posdtl.managefee;
    transdtl.custid = trans.custid;
    transdtl.sysid = posdtl.sysid;
    des2src(transdtl.devphyid, posdtl.devphyid);
    transdtl.devseqno = posdtl.devseqno;
    transdtl.offlineflag = posdtl.datatype;
    des2src(transdtl.showcardno, tCard.showcardno);
    transdtl.status = TRANSTATUS_SUCC;
    if(trans.custid)
    {
        GetCustBaseInfoByCustID(trans.custid, trans.custname, trans.stuempno, trans.deptcode);
    }
    des2src(transdtl.custname, trans.custname);
    des2src(transdtl.stuempno, trans.stuempno);
    ret = DB_t_transdtl_add(&transdtl);
    if(ret)
    {
        if(DB_REPEAT == ret)
            return E_DB_TRANSDTL_E;
        else
            return E_DB_TRANSDTL_I;
    }
    return 0;
}
//联机冲正,当日即时冲正
int OnlineTransRev(char *oldaccdate, int oldtermid, int oldtermseqno)
{
    int ret = 0;
    CAccTrans *pAccTrans = CAccTrans::getInstance();
    TRANS& trans = pAccTrans->trans;

    T_t_transdtl transdtl;
    memset(&transdtl, 0, sizeof(transdtl));
    ret = DB_t_transdtl_read_lock_by_c0_and_accdate_and_termid_and_termseqno(oldaccdate, oldtermid, oldtermseqno, &transdtl);
    if(ret)
    {
        LOG(ERROR, "ret[" << ret << "]accdate[" << oldaccdate << "]termid[" << oldtermid << "]termseqno[" << oldtermseqno << "]");
        if(DB_NOTFOUND == ret)
            return E_DB_TRANSDTL_N;
        else
            return E_DB_TRANSDTL_R;
    }
    if(1 == transdtl.revflag)
    {
        DB_t_transdtl_free_lock_by_c0();
        pAccTrans->remark = "该交易已冲正";
        return 0;
    }
    transdtl.revflag = 1;
    ret = DB_t_transdtl_update_lock_by_c0(&transdtl);
    if(ret)
    {
        LOG(ERROR, "UpdateTransdtlRevFlag ret[" << ret << "]accdate[" << oldaccdate << "]termid[" << oldtermid << "]termseqno[" << oldtermseqno << "]");
        return ret;
    }
    if(transdtl.cardcnt > 0 && transdtl.cardno > 0)
    {
        if(TF_PAY == transdtl.transflag)
        {
            ret = UpdateCardBitmap(transdtl.cardno, transdtl.cardcnt, CARDBITMAPTYPE_REV);
            if(ret)
            {
                LOG(ERROR, "UpdateCardBitmap err ret[" << ret << "]cardno[" << transdtl.cardno << "]cardcnt[" << transdtl.cardcnt << "]");
            }
        }
    }
    if(strlen(trans.opercode))
    {
        if(strcmp(transdtl.opercode, pAccTrans->trans.opercode) != 0)
        {
            des2src(transdtl.opercode, trans.opercode);
        }
    }
    /*
    if(transdtl.cardno)
    {
      T_t_card card;
      memset(&card,0,sizeof(card));
      ret=DB_t_card_read_by_cardno(transdtl.cardno,&card);
      if(ret)
      {
          if(DB_NOTFOUND==ret)
              return ERRINFO(E_NOTEXIST_CARDNO,transdtl.cardno);
          else
              return E_DB_CARD_R;
      }
      strcpy(pAccTrans->trans.cardaccno,card.accno);
    }
    */
    trans.cardno = transdtl.cardno;
    trans.cardflag = 0;
    trans.offlineflag = 1;
    trans.revflag = 1; //冲正标志
    trans.cardbefbal = D2I(transdtl.cardbefbal * 100);
    trans.cardaftbal = D2I(transdtl.cardbefbal * 100);
    trans.transflag = transdtl.transflag;
    if(TF_DPS == trans.transflag)
    {
        trans.dpscnt = transdtl.cardcnt - 1;
        trans.aftdpscnt = trans.dpscnt;
    }
    if(TF_PAY == trans.transflag)
    {
        trans.paycnt = transdtl.cardcnt - 1;
        trans.aftpaycnt = trans.paycnt;
    }
    ret = GetAccnoByCardno(trans.cardno, trans.cardaccno);
    if(ret)
        return ret;
    ret = pAccTrans->doTodayReverseTrans(oldaccdate, oldtermid, oldtermseqno);
    if(ret)
        return ret;
    memset(&transdtl, 0, sizeof(transdtl));
    if(strlen(trans.refno) < 1)
    {
        ret = pAccTrans->GetNewRefno(trans.refno);
        if(ret)
            return ret;
    }
    des2src(transdtl.refno, trans.refno);
    transdtl.cardaftbal = transdtl.cardbefbal;
    transdtl.revflag = 0;
    strcpy(transdtl.accdate, pAccTrans->trans.accdate);
    strcpy(transdtl.acctime, pAccTrans->trans.acctime);
    des2src(transdtl.transdate, pAccTrans->trans.transdate);
    des2src(transdtl.transtime, pAccTrans->trans.transtime);
    transdtl.transcode = pAccTrans->trans.transcode;
    transdtl.termid = pAccTrans->trans.termid;
    transdtl.termseqno = pAccTrans->trans.termseqno;
    transdtl.amount = -transdtl.amount;
    transdtl.managefee = -transdtl.managefee;
    ret = DB_t_transdtl_add(&transdtl);
    if(ret)
    {
        if(DB_REPEAT == ret)
            return E_DB_TRANSDTL_E;
        else
            return E_DB_TRANSDTL_I;
    }
    return 0;
}
//冲账交易
int AccTransRev(const char *oldaccdate, const char *oldrefno, const char* remark)
{
    CAccTrans& ats = CAccTrans::GetInst();
    TRANS& trans = ats.trans;
    trans.revflag = 1; //冲正标志

    char transdtlname[61] = {0};
    int ret = GetTransdtlTableName(oldaccdate, transdtlname);
    if(ret)
    {
        LOG(ERROR, "GetTransdtlTableName err");
        return ret;
    }
    T_t_transdtl orig_transdtl;
    memset(&orig_transdtl, 0, sizeof(orig_transdtl));
    ret = ReadTransdtlData(transdtlname, oldaccdate, oldrefno, orig_transdtl);
    if(ret)
    {
        LOG(ERROR, "ReadTransdtlData transdtlname[" << transdtlname << "],oldaccdate[" << oldaccdate << "],oldrefno[" << oldrefno << "]");
        return ret;
    }
    if(3 != orig_transdtl.status)
    {
        ERRTIP("原交易失败,不需要冲正");
        return E_COMMON_ERR;
    }
    if(1 == orig_transdtl.revflag)
    {
        ERRTIP("该交易已冲正");
        return E_COMMON_ERR;
    }
    if(amtcmp(ats.trans.inputamt, 0) != 0)
    {
        if(amtcmp(ats.trans.inputamt, orig_transdtl.amount) != 0)
        {
            ERRTIP("冲正金额与原交易金额不等");
            return E_COMMON_ERR;
        }
    }
    ret = UpdateTransdtlHisRevFlag(transdtlname, oldaccdate, orig_transdtl.termid, orig_transdtl.termseqno);
    if(ret)
    {
        LOG(ERROR, "UpdateTransdtlRevFlag ret[" << ret << "]accdate[" << oldaccdate << "]termid[" << orig_transdtl.termid << "]termseqno[" << orig_transdtl.termseqno << "]");
        return ret;
    }
    if(orig_transdtl.cardcnt > 0 && orig_transdtl.cardno > 0)
    {
        if(TF_PAY == orig_transdtl.transflag)
        {
            ret = UpdateCardBitmap(orig_transdtl.cardno, orig_transdtl.cardcnt, CARDBITMAPTYPE_REV);
            if(ret)
            {
                LOG(ERROR, "UpdateCardBitmap err ret[" << ret << "]cardno[" << orig_transdtl.cardno << "]cardcnt[" << orig_transdtl.cardcnt << "]");
            }
        }
    }
    if(strlen(orig_transdtl.opercode))
    {
        if(strcmp(orig_transdtl.opercode, ats.trans.opercode) != 0)
        {
            return ERRINFO(E_REVOPER, orig_transdtl.opercode);
        }
    }
    trans.cardno = orig_transdtl.cardno;
    trans.cardflag = 0;
    trans.offlineflag = 1;
    trans.revflag = 1; //冲正标志
    ret = GetAccnoByCardno(trans.cardno, trans.cardaccno);
    if(ret)
        return ret;
    ret = ats.doHistoryReverseTrans(oldaccdate, orig_transdtl.termid, orig_transdtl.termseqno);
    if(ret)
        return ret;
    if(TC_POSDRAWREV == ats.trans.transcode ||
       TC_CARDDEPOSITREV == ats.trans.transcode ||
       TC_CARDOPENREV == ats.trans.transcode)
        return 0;
    if(strlen(trans.refno) < 1)
    {
        ret = ats.GetNewRefno(trans.refno);
        if(ret)
            return ret;
    }
    T_t_transdtl transdtl;
    memset(&transdtl, 0, sizeof(transdtl));
    des2src(transdtl.refno, trans.refno);
    des2src(transdtl.opercode, trans.opercode);
    transdtl.revflag = 0;
    strcpy(transdtl.accdate, ats.trans.accdate);
    strcpy(transdtl.acctime, ats.trans.acctime);
    des2src(transdtl.transdate, ats.trans.transdate);
    des2src(transdtl.transtime, ats.trans.transtime);
    transdtl.transcode = ats.trans.transcode;
    transdtl.termid = ats.trans.termid;
    transdtl.termseqno = ats.trans.termseqno;
    transdtl.amount = -transdtl.amount;
    transdtl.managefee = -transdtl.managefee;
    des2src(transdtl.remark, remark);
    ret = DB_t_transdtl_add(&transdtl);
    if(ret)
    {
        if(DB_REPEAT == ret)
            return E_DB_TRANSDTL_E;
        else
            return E_DB_TRANSDTL_I;
    }
    return 0;
}
int GetTransPackStatus(char *packetid, char *reqid, T_t_transpack* transpack)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char        hi_packetid[21] = {0};
        char        hi_reqid[21] = {0};
        char    rowid[31] = {0};
        int     revflag = 0; //冲正标志:0表示正常记录1表示冲正记录
        int     retrycnt = 0; //重试次数
        char     status[2] = {0}; //处理状态:N未处理S成功R否决F失败D过期C撤销B退票V拒绝
        int     errcode = 0; //错误码
        char     errmsg[241] = {0}; //错误消息
        char     lastupdtime[31] = {0}; //最后更新时间
        short indicator = 0;
    EXEC SQL END DECLARE SECTION;
    int ret = 0;
    des2src(hi_packetid, packetid);
    des2src(hi_reqid, reqid);
    memset(transpack, 0, sizeof(T_t_transpack));
    EXEC SQL DECLARE transpack_cur CURSOR FOR
    SELECT
     rowid,
     revflag,
     retrycnt,
     status,
     errcode,
     errmsg,
     lastupdtime
    FROM t_transpack
    where  packetid=:hi_packetid and reqid=:hi_reqid;
    if(SQLCODE)
    {
        LOG(ERROR, "read transpack packetid[" << hi_packetid << "]reqid[" << hi_reqid << "]");
        CHECK_DB_ERR;
        return E_DB_CURSOR_DECLARE;
    }
    EXEC SQL OPEN transpack_cur;
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        return E_DB_CURSOR_OPEN;
    }
    EXEC SQL FETCH transpack_cur INTO
    :rowid:indicator,
    :revflag:indicator,
    :retrycnt:indicator,
    :status:indicator,
    :errcode:indicator,
    :errmsg:indicator,
    :lastupdtime:indicator;
    if(SQLCODE)
    {
        LOG(ERROR, "read transpack packetid[" << hi_packetid << "]reqid[" << hi_reqid << "]");
        ret = SQLCODE;
        CHECK_DB_ERR;
        EXEC SQL CLOSE transpack_cur;
        if(DB_NOTFOUND == ret)
            return E_DB_TRANSPACK_N;
        else
            return E_DB_TRANSPACK_R;
    }
    EXEC SQL CLOSE transpack_cur;
    transpack->revflag = revflag;
    transpack->retrycnt = retrycnt;
    des2src(transpack->status, status);
    transpack->errcode = errcode;
    des2src(transpack->errmsg, errmsg);
    des2src(transpack->lastupdtime, lastupdtime);
    return 0;
}
int UpdTranspackStatus(char *packetid, char *reqid, const T_t_transpack& transpack)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char    hi_packetid[21] = {0};
        char    hi_reqid[21] = {0};
        int     hi_revflag = 0; //冲正标志:0表示正常记录1表示冲正记录
        int     hi_retrycnt = 0; //重试次数
        char    hi_status[2] = {0}; //处理状态:N未处理S成功R否决F失败D过期C撤销B退票V拒绝
        int     hi_errcode = 0; //错误码
        char    hi_errmsg[241] = {0}; //错误消息
        char    hi_lastupdtime[31] = {0}; //最后更新时间
    EXEC SQL END DECLARE SECTION;
    des2src(hi_packetid, packetid);
    des2src(hi_reqid, reqid);
    hi_revflag = transpack.revflag;
    hi_retrycnt = transpack.retrycnt;
    des2src(hi_status, transpack.status);
    hi_errcode = transpack.errcode;
    des2src(hi_errmsg, transpack.errmsg);
    des2src(hi_lastupdtime, transpack.lastupdtime);
    EXEC SQL
    update t_transpack
    set status=:hi_status,errcode=:hi_errcode,errmsg=:hi_errmsg,
      retrycnt=:hi_retrycnt,lastupdtime=:hi_lastupdtime
    where  packetid=:hi_packetid and reqid=:hi_reqid;
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        LOG(ERROR, "update transpack packetid[" << hi_packetid << "]reqid[" << hi_reqid << "]");
        if(DB_NOTFOUND == SQLCODE)
            return E_DB_TRANSPACK_N;
        else
            return E_DB_TRANSPACK_U;
    }
    return 0;
}
//
int SaveCardTransInfo()
{
    CAccTrans *pAccTrans = CAccTrans::getInstance();
    TRANS& trans = pAccTrans->trans;
    T_t_cardtrans CardtransOrgi;
    T_t_cardtrans CardtransNew;
    memset(&CardtransOrgi, 0, sizeof(CardtransOrgi));
    memset(&CardtransNew, 0, sizeof(CardtransNew));

    CardtransOrgi.cardno = trans.cardno;

    CardtransNew.cardno = CardtransOrgi.cardno;
    strcpy(CardtransNew.transdate, trans.transdate);
    strcpy(CardtransNew.transtime, trans.transtime);
    CardtransNew.transcode = trans.transcode;
    CardtransNew.termid = trans.termid;
    CardtransNew.termseqno = trans.termseqno;
    CardtransNew.dpscnt = trans.dpscnt;
    CardtransNew.paycnt = trans.paycnt;
    CardtransNew.amount = (trans.cardaftbal - trans.cardbefbal) / 100.0;
    CardtransNew.cardbefbal = trans.cardbefbal / 100.0;
    CardtransNew.cardaftbal = trans.cardaftbal / 100.0;
    CardtransNew.updcnt = 0;
    strcpy(CardtransNew.updtime, trans.sysdatetime);
    int ret = DB_t_cardtrans_read_lock_by_c0_and_cardno(CardtransNew.cardno, &CardtransOrgi);
    if(ret)
    {
        if(DB_NOTFOUND == ret)
        {
            ret = DB_t_cardtrans_add(&CardtransNew);
            if(ret)
            {
                return E_DB_CARDTRANS_I;
            }
            return 0;
        }
        else
            return E_DB_CARDTRANS_R;
    }
    ret = DB_t_cardtrans_update_lock_by_c0(&CardtransNew);
    if(ret)
    {
        return E_DB_CARDTRANS_U;
    }
    return 0;
}
//计算预存搭伙费
int CalcPrestoreFee(int feetype, int transamt, int* feeamt)
{
    char sysparaval[21] = {0};
    int ret = GetSysParaVal(SYSPARA_SHOPBOARDFEEFLAG, sysparaval);            // 搭伙费收取模式
    if(ret)
    {
        ERRTIP("搭伙费模式参数未设置");
        return E_COMMON_ERR;
    }
    *feeamt = 0;
    if(atoi(sysparaval) == 2)                     // 预收搭伙费(三九模式)
    {
        ERRTIP("搭伙费预收模式已取消");
        return E_COMMON_ERR;
        /*
        T_t_feetype tFeetype;
        memset(&tFeetype, 0, sizeof tFeetype);
        ret = DB_t_feetype_read_by_feetype(feetype, &tFeetype);
        if(ret)
        {
            if(DB_NOTFOUND == ret)
                return E_NOTEXIST_FEETYPE;
            else
                return E_DB_FEETYPE_R;
        }
        if(tFeetype.boardfeeflag[0] == '1')
        {
            *feeamt = D2I(tFeetype.feerate * transamt);
        }
        else
        {
            *feeamt = 0;
        }
        */
    }
    return 0;
}
int MoveAccBal2Frozebal(char* accno, int amount)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char hi_accno[11] = {0};
        double hi_amount = 0;
        char ho_status[2] = {0};
        double ho_frozebal = 0;
        double ho_availbal = 0;
        sqlint16 ho_idr;
    EXEC SQL END DECLARE SECTION;
    if(0 == amount)
        return 0;
    des2src(hi_accno, accno);
    hi_amount = D4U5(amount / 100.0, 2);
    SQLCODE = 0;
    EXEC SQL
       declare account_cursor cursor for
       select status,frozebal,availbal
       from T_ACCOUNT
       where accno=:hi_accno for update;
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        return E_DB_CURSOR_DECLARE;
    }
    EXEC SQL open account_cursor;
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        return E_DB_CURSOR_DECLARE;
    }
    EXEC SQL
     fetch account_cursor into
       :ho_status:ho_idr,
       :ho_frozebal:ho_idr,
       :ho_availbal:ho_idr;
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        if(DB_NOTFOUND == SQLCODE)
        {
            EXEC SQL close account_cursor;
            return E_NOTEXIST_CARDACCNO;
        }
        else
        {
            EXEC SQL close account_cursor;
            return E_DB_ACCOUNT_R;
        }
    }
    if(ho_status[0] != STATUS_NORMAL)
    {
        EXEC SQL close account_cursor;
        return E_CARDACC_LOGOUT;
    }
    EXEC SQL
    update t_account
    set frozebal = frozebal+:hi_amount,
    availbal = availbal - :hi_amount
    WHERE current of account_cursor;
    if(SQLCODE)
    {
        EXEC SQL close account_cursor;
        CHECK_DB_ERR;
        LOG(ERROR, "sqlcode[" << SQLCODE << "]accno[" << accno << "]");
        return E_DB_ACCOUNT_U;
    }
    EXEC SQL close account_cursor;
    return 0;
}

int MoveAccForegift(const char* outaccno, const char* inaccno)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char hi_inaccno[11] = {0};
        char hi_outaccno[11] = {0};
        sqlint16 ho_idr;
    EXEC SQL END DECLARE SECTION;

    des2src(hi_outaccno, outaccno);
    des2src(hi_inaccno, inaccno);
    SQLCODE = 0;
    EXEC SQL
     update t_account set foregift=(select foregift from t_account where accno=:hi_outaccno)
     where accno=:hi_inaccno;
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        LOG(ERROR, "sqlcode[" << SQLCODE << "]outaccno[" << outaccno << "]");
        return E_DB_ACCOUNT_U;
    }
    SQLCODE = 0;
    EXEC SQL
     update t_account set foregift=0
     where accno=:hi_outaccno;
    if(SQLCODE)
    {
        CHECK_DB_ERR;
        LOG(ERROR, "sqlcode[" << SQLCODE << "]outaccno[" << outaccno << "]");
        return E_DB_ACCOUNT_U;
    }
    return 0;
}

//计算开户或补办的手续费
int CalcTransFee(int feetype, int cardtype, int transcode, int freefeeflag, int& feeamt, char *feeinfo)
{
    int ret = 0;
    ret = CAccTrans::GetInst().CheckCfgUpdate();
    if(ret)
        return ret;
    T_t_feetype tFeetype;
    memset(&tFeetype, 0, sizeof(tFeetype));
    ret = DB_t_feetype_read_by_feetype(feetype, &tFeetype);
    if(ret)
    {
        if(DB_NOTFOUND == ret)
            return ERRINFO(E_NOTEXIST_FEETYPE, feetype);
        else
            return E_DB_FEETYPE_R;
    }
    T_t_cardtype tCardtype;
    memset(&tCardtype, 0, sizeof tCardtype);
    ret = DB_t_cardtype_read_by_cardtype(cardtype, &tCardtype);
    if(ret)
    {
        CHECK_DB_ERR;
        if(DB_NOTFOUND == ret)
            return ERRINFO(E_NOTEXIST_CARDTYPE, cardtype);
        else
            return E_DB_CARDTYPE_R;
    }
    int haskkey = MAKELONG(cardtype, transcode);
    list<CfgFee>::iterator itList;
    MAPCFGFEELIST::iterator itFeeList;
    CAccTrans& ats = CAccTrans::GetInst();
    itFeeList = ats.mapFeeList.find(haskkey);
    if(itFeeList == ats.mapFeeList.end())
    {
        stringstream ss;
        ss << "收费类别[" << tFeetype.feename << "]卡类型[" << tCardtype.cardtypename << "]交易码[" << transcode << "]业务未配置收费参数";
        LOG(ERROR, ss.str());
        ERRTIP(ss.str().c_str());
        return  E_COMMON_ERR;
    }
    int row = 0;
    list<CfgFee>& FeeList = itFeeList->second;
    for(itList = FeeList.begin(); itList != FeeList.end(); itList++)
    {
        if(feetype == itList->feetype)
            break;
    }
    if(itList == FeeList.end())
    {
        //没找到本收费类别配置项,则查找通用配置项
        feetype = FEETYPE_COMM;
    }
    int totalfee = 0;
    string sFeeInfo = "";
    for(itList = FeeList.begin(); itList != FeeList.end(); itList++)
    {
        if(feetype != itList->feetype)
            continue;
        //对于补办卡时押金和卡成本费在卡自然损坏的时候不收费
        if(TRANSTYPE_CARDCOSTFEE == itList->transtype)
        {
            if(freefeeflag)
            {
                sFeeInfo += "卡成本费免收 ";
                row++;
                continue;
            }
        }
        if(TRANSTYPE_FOREGIFT == itList->transtype)
        {
            if(freefeeflag)
            {
                sFeeInfo += "卡押金免收 ";
                sFeeInfo    += " ";
                row++;
                continue;
            }
        }
        //计算交易金额
        switch(itList->ratetype)
        {
            case 1:
                totalfee = D2I(totalfee + itList->rateamt * 100);
                sFeeInfo  += itList->remark;
                sFeeInfo  += " ";
                break;
            case 2:
                ERRTIP("交易配置错误");
                return E_COMMON_ERR;
            default:
                break;
        }
        row++;
    }
    if(!row)
    {
        ERRTIP("卡类型[%s]交易代码[%d]客户收费类别[%s]收费参数未配置", tCardtype.cardtypename, transcode, tFeetype.feename);
        return E_COMMON_ERR;
    }
    feeamt = totalfee;
    strcpy(feeinfo, sFeeInfo.c_str());
    return 0;
}
//计算充值手续费
int CalcDpsFee(int feetype, int amount, int& dpsfee)
{
    T_t_feetype tFeetype;
    memset(&tFeetype, 0, sizeof(tFeetype));
    int ret = DB_t_feetype_read_by_feetype(feetype, &tFeetype);
    if(ret)
    {
        if(DB_NOTFOUND == ret)
            return E_NOTEXIST_FEETYPE;
        else
            return E_DB_FEETYPE_R;
    }
    if(tFeetype.dpsrate > 0)
        dpsfee = D2I(tFeetype.dpsrate * amount / 100.0);
    else
        dpsfee = 0;
    return 0;
}

